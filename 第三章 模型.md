#第三章 模型

这一章，我们将会讨论以下话题：

 - 模型的重要性
 - 类图
 - 模型的结构模式
 - 模型的行为模式
 - 数据库迁移

##M比V和C都重要

在Django里，模型是可以以面向对象的方式与数据库交互的类。一般来说，一个类对应数据库里的一张表，而一个类的属性对应数据库里的一列。你可以用自动生成的API来发出数据库请求。

模型是其他所有组件的基础。一旦你有了模型，你马上就可以使用模型管理器，模型表单和各种各样的通用视图。使用它们中的任何一个你仍然需要一两行代码，不然它们也过于神奇了。

而且，能用到模型的地方远比你想象的多。这主要是因为Django有很多种运行方式。这些方式中包括：

 - 常规的Web“请求-响应"流程
 - Django互动命令行
 - 管理命令
 - 测试脚本
 - 异步任务执行器，比如Celery

在几乎所有这些方式下，模型模块都会被引入(作为`django.setup()`过程的一部分)。因此，尽可能减少你模型里不必要的依赖包以及其他Django模块，比如视图。

总而言之，好好设计你的模型非常重要。下面让我们开始SuperBook模型的设计。

>__午餐研讨会__
>
>_笔者注：SuperBook项目的进度会以这样的形式呈现出来。你可以跳过这样的部分，但那样你就会错过开发Web应用项目能了解到的，经历到的东西，以及一些有趣的事情。_
>
>Steve与他的客户，超级英雄情报与监视局，简称S.H.I.M合作的第一个星期经历比较复杂。整个办公室非常有未来感，但是任何事情都需要层层批准签字。
>
>作为Django开发者领队，Steve花了两天时间搭建好了一个中等规模的服务器，运行着四个虚拟机。但是接下来的一天，这个服务器消失了。旁边一个洗碗机大小的机器人说这个服务器因为安装未经许可的软件被取证部门收走了。不过好在公司的CTO，Hart伸出了援手。他在一个小时内就要回了服务器，里面已安装的软件也完好无损。为了防止以后再发生类似的事情，他还预批准了这台机器上所有的软件安装。
>
>当天下午，Steve和他进行了一场午餐研讨会。Hart穿着一身米色西装和淡蓝色牛仔裤准时到场。尽管他比很多人都要高，还留着光头，他仍然让人觉得非常好相处。他问Steve有没有看看之前60年代为超级英雄建立数据库的尝试。
>
>“啊，有的，Sentinel项目，对吧？”Steve说道。“我看了。那个数据库好像是用入口－属性－值的模型设计的，我觉得这比较反模式。估计那时候他们并不清楚超级英雄有多少属性。”Hart在听到最后一句话的时候几乎打了个寒噤。他用稍低的声音说道，“你是对的，我确实不知道。而且他们当时只给了我两天就要我设计出整个项目。我觉得这个项目有很大的问题。”Steve长大了嘴巴，送到一半的三明治也停在了嘴边。Hart笑到，“这显然不是我的得意项目。一旦超过十亿条记录，在那个数据库上进行的任何数据分析都要花几天。SuperBook只需要几秒钟对吧？”
>
>Steve轻轻点了点头。他一开始也完全没想到会有接近十亿的超级英雄。

##模型分析

这里是定义SuperBook模型的第一步。一般来说，对于早期尝试，我们只把最本质的模型和它们之间的关系表示为一个类图：

![3-1](images/3-1.png)

我们先不管模型，让我们先从对象的角度来建模。每个用户都有一个用户资料。一个用户可以对数个发布内容作出多次评论。一个__赞__和一个用户/发布内容的组合关联。

我们很推荐像这样为你的模型画一个类图。它们也许不包含所有的属性，但是你可以之后再去关注这些细节。当整个项目都被画上了类图后，要把它们分成应用就会更简单。

这里是画类图时的一些小建议：

 - 方框代表一个实体，最后会变成模型。
 - 在你的概念文档里的名词一般都是实体。
 - 箭头是双向的，在Django里可以表示以下三种关系中的一种：一对一，一对多(以外键方式实现)和多对多。
 - 标出一对多关系的属性应该在实体关系模型(ER-model)中定义出来的。换句话说，标星号的地方即是应该声明外键的地方。

这个类图可以对应到如下的Django代码中(它们可以分布在不同的应用里)：

	class Profile(models.Model):
		user = models.OneToOneField(User)

	class Post(models.Model):
		posted_by = models.ForeignKey(User)

	class Comment(models.Model):
		commented_by = models.ForeignKey(User)
		for_post = models.ForeignKey(Post)

	class Like(models.Model):
		liked_by = models.ForeignKey(User)
		post = models.ForeignKey(Post)

之后我们会看到，我们不再直接调用`User`，而是调用更通用的`settings.AUTH_USER_MODEL`。

##将`models.py`分解成多个文件

就像Django的其它组件一样，一个巨大的`models.py`文件也可以被分成多个文件放在同一个软件包里。一个__软件包__一般以目录的形式实现，里面可以包括数个文件，但必须包含一个特殊的名为`__init__.py`的文件。

所有能通过包访问的类必须声明在`__init__.py`里面。举个例子，如果我们把`models.py`分成一个个单独的类，对应的models文件夹里的子类文件分别是`postable.py`，`post.py`，`comment.py`，那么`__init__.py`文件应该像这样：

	from postable import Postable
	from post import Post
	from comment import Comment

现在你可以像之前一样引用`models.Post`了。

`__init__.py`文件里的其它代码在引入的时候也会执行。所以这也是对包进行初始化的理想位置。

##结构模式

这一部分包含了几种可以帮助你设计和架构模型的模式。

###模式 － 标准化模型

__问题__： 设计上，模型的实例会有重复的数据，可能会导致数据不连续。

__解决方案__： 通过标准化，将你的模型分解成更小的模型。通过逻辑关系连接他们。

####问题细节

设想有人将我们的Post表设计成如下的样子(忽略特定的列)：

<table>
	<tr>
		<th>超级英雄名</th>
		<th>信息</th>
		<th>发布于</th>
	</tr>
	<tr>
		<td>Captain Temper</td>
		<td>Has this posted yet?</th>
		<td>2012/07/07 07:15</th>
	</tr>
	<tr>
		<td>Professor English</td>
		<td>It should be 'Is' not 'Has'.</th>
		<td>2012/07/07 07:17</th>
	</tr>
	<tr>
		<td>Captain Temper</td>
		<td>Has this posted yet?</th>
		<td>2012/07/07 07:18</th>
	</tr>
	<tr>
		<td>Capt. Temper</td>
		<td>Has this posted yet?</th>
		<td>2012/07/07 07:19</th>
	</tr>
</table>

但愿你注意到了最后一行超级英雄名字的不一致性(以及队长一贯的没耐心)

如果我们只看第一列，我们根本不能确定哪一个拼写是正确的——_Captain Temper_还是_Capt. Temper_。这正是我们需要通过标准化消除的冗余数据。

####解决方案细节

在我们介绍完整的标准化解决方案之前，让我们先来简单看一眼Django环境下的数据库层面的标准化。

#####标准化的三步

标准化可以帮助你更高效地存储数据。当你的模型完全地标准化了，他们不应该有任何的冗余数据，每个模型也只会包含与它逻辑相关的数据。

举个简单的例子，如果我们要标准化Post表好让我们可以随意将信息与超级英雄关联，那我们就得把用户信息分离到单独的一个表里。Django默认已经创建了用户表。所以，你只需要引用发布信息的用户的ID就可以了，如下表所示：

<table>
	<tr>
		<th>超级英雄ID</th>
		<th>信息</th>
		<th>发布于</th>
	</tr>
	<tr>
		<td>12</td>
		<td>Has this posted yet?</th>
		<td>2012/07/07 07:15</th>
	</tr>
	<tr>
		<td>8</td>
		<td>It should be 'Is' not 'Has'.</th>
		<td>2012/07/07 07:17</th>
	</tr>
	<tr>
		<td>12</td>
		<td>Has this posted yet?</th>
		<td>2012/07/07 07:18</th>
	</tr>
	<tr>
		<td>12</td>
		<td>Has this posted yet?</th>
		<td>2012/07/07 07:19</th>
	</tr>
</table>

现在不光我们知道有三条数据来自同一个用户(ID是随意给的)，而且我们也能通过查询用户表获取正确的用户名了。

一般来说，你需要先以完全标准化的形式设计你的模型，然后因为性能原因选择性地去标准化一部分。在数据库里，__标准化范式__是一系列可以用来确保你的表是标准化的规则。常用的范式有第一，第二和第三范式，尽管最多可以一直到第五范式。

下一个例子里，我们将会标准化一张表，并创建对应的Django模型。设想有一张名为“_目击_”的表，其中列出了超级英雄第一次被目击使用某种能力或超人类力量。每一条记录储存了他们的出身，超能力，第一次目击的位置，包括经度和纬度。

<table>
	<tr>
		<th>姓名</th>
		<th>出身</th>
		<th>超能力</th>
		<th>第一次目击(经度，纬度，国家，时间)</th>
	</tr>
	<tr>
		<td>Blitz</td>
		<td>外星人</td>
		<td>
			冰冻<br>
			飞行
		</td>
		<td>
			+40.75，-73.99；USA；2014/07/03 23:12<br>
			+34.05，-118.24；USA；2013/03/12 11:30
		</td>
	</tr>
	<tr>
		<td>Hexa</td>
		<td>科学家</td>
		<td>
			念动<br>
			飞行
		</td>
		<td>
			+35.68，+139.73；Japan；2010/02/17 20:15<br>
			+31.23，+121.45；China；2010/02/19 20:30
		</td>
	</tr>
	<tr>
		<td>Traveller</td>
		<td>亿万富翁</td>
		<td>时间旅行</td>
		<td>
			+43.62，+1.45；法国；2010/11/10 08:20
		</td>
	</tr>
</table>

以上位置数据来自[http://www.golombek.com/locations.html](http://www.golombek.com/locations.html)

