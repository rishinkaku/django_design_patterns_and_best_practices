#第三章 模型

这一章，我们将会讨论以下话题：

 - 模型的重要性
 - 类图
 - 模型的结构模式
 - 模型的行为模式
 - 数据库迁移

##M比V和C都重要

在Django里，模型是可以以面向对象的方式与数据库交互的类。一般来说，一个类对应数据库里的一张表，而一个类的属性对应数据库里的一列。你可以用自动生成的API来发出数据库请求。

模型是其他所有组件的基础。一旦你有了模型，你马上就可以使用模型管理器，模型表单和各种各样的通用视图。使用它们中的任何一个你仍然需要一两行代码，不然它们也过于神奇了。

而且，能用到模型的地方远比你想象的多。这主要是因为Django有很多种运行方式。这些方式中包括：

 - 常规的Web“请求-响应"流程
 - Django互动命令行
 - 管理命令
 - 测试脚本
 - 异步任务执行器，比如Celery

在几乎所有这些方式下，模型模块都会被引入(作为`django.setup()`过程的一部分)。因此，尽可能减少你模型里不必要的依赖包以及其他Django模块，比如视图。

总而言之，好好设计你的模型非常重要。下面让我们开始SuperBook模型的设计。

>__午餐研讨会__
>
>_笔者注：SuperBook项目的进度会以这样的形式呈现出来。你可以跳过这样的部分，但那样你就会错过开发Web应用项目能了解到的，经历到的东西，以及一些有趣的事情。_
>
>Steve与他的客户，超级英雄情报与监视局，简称S.H.I.M合作的第一个星期经历比较复杂。整个办公室非常有未来感，但是任何事情都需要层层批准签字。
>
>作为Django开发者领队，Steve花了两天时间搭建好了一个中等规模的服务器，运行着四个虚拟机。但是接下来的一天，这个服务器消失了。旁边一个洗碗机大小的机器人说这个服务器因为安装未经许可的软件被取证部门收走了。不过好在公司的CTO，Hart伸出了援手。他在一个小时内就要回了服务器，里面已安装的软件也完好无损。为了防止以后再发生类似的事情，他还预批准了这台机器上所有的软件安装。
>
>当天下午，Steve和他进行了一场午餐研讨会。Hart穿着一身米色西装和淡蓝色牛仔裤准时到场。尽管他比很多人都要高，还留着光头，他仍然让人觉得非常好相处。他问Steve有没有看看之前60年代为超级英雄建立数据库的尝试。
>
>“啊，有的，Sentinel项目，对吧？”Steve说道。“我看了。那个数据库好像是用入口－属性－值的模型设计的，我觉得这比较反模式。估计那时候他们并不清楚超级英雄有多少属性。”Hart在听到最后一句话的时候几乎打了个寒噤。他用稍低的声音说道，“你是对的，我确实不知道。而且他们当时只给了我两天就要我设计出整个项目。我觉得这个项目有很大的问题。”Steve长大了嘴巴，送到一半的三明治也停在了嘴边。Hart笑到，“这显然不是我的得意项目。一旦超过十亿条记录，在那个数据库上进行的任何数据分析都要花几天。SuperBook只需要几秒钟对吧？”
>
>Steve轻轻点了点头。他一开始也完全没想到会有接近十亿的超级英雄。

##模型分析

这里是定义SuperBook模型的第一步。一般来说，对于早期尝试，我们只把最本质的模型和它们之间的关系表示为一个类图：

![3-1](images/3-1.png)

我们先不管模型，让我们先从对象的角度来建模。每个用户都有一个用户资料。一个用户可以对数个发布内容作出多次评论。一个__赞__和一个用户/发布内容的组合关联。

我们很推荐像这样为你的模型画一个类图。它们也许不包含所有的属性，但是你可以之后再去关注这些细节。当整个项目都被画上了类图后，要把它们分成应用就会更简单。

这里是画类图时的一些小建议：

 - 方框代表一个实体，最后会变成模型。
 - 在你的概念文档里的名词一般都是实体。
 - 箭头是双向的，在Django里可以表示以下三种关系中的一种：一对一，一对多(以外键方式实现)和多对多。
 - 标出一对多关系的属性应该在实体关系模型(ER-model)中定义出来的。换句话说，标星号的地方即是应该声明外键的地方。

这个类图可以对应到如下的Django代码中(它们可以分布在不同的应用里)：

	class Profile(models.Model):
		user = models.OneToOneField(User)

	class Post(models.Model):
		posted_by = models.ForeignKey(User)

	class Comment(models.Model):
		commented_by = models.ForeignKey(User)
		for_post = models.ForeignKey(Post)

	class Like(models.Model):
		liked_by = models.ForeignKey(User)
		post = models.ForeignKey(Post)

之后我们会看到，我们不再直接调用`User`，而是调用更通用的`settings.AUTH_USER_MODEL`。

##将`models.py`分解成多个文件

就像Django的其它组件一样，一个巨大的`models.py`文件也可以被分成多个文件放在同一个软件包里。一个__软件包__一般以目录的形式实现，里面可以包括数个文件，但必须包含一个特殊的名为`__init__.py`的文件。

所有能通过包访问的类必须声明在`__init__.py`里面。举个例子，如果我们把`models.py`分成一个个单独的类，对应的models文件夹里的子类文件分别是`postable.py`，`post.py`，`comment.py`，那么`__init__.py`文件应该像这样：

	from postable import Postable
	from post import Post
	from comment import Comment

现在你可以像之前一样引用`models.Post`了。

`__init__.py`文件里的其它代码在引入的时候也会执行。所以这也是对包进行初始化的理想位置。

##结构模式

这一部分包含了几种可以帮助你设计和架构模型的模式。

###模式 － 标准化模型

__问题__： 设计上，模型的实例会有重复的数据，可能会导致数据不连续。

__解决方案__： 通过标准化，将你的模型分解成更小的模型。通过逻辑关系连接他们。

####问题细节

设想有人将我们的Post表设计成如下的样子(忽略特定的列)：

<table>
	<tr>
		<th>超级英雄名</th>
		<th>信息</th>
		<th>发布于</th>
	</tr>
	<tr>
		<td>Captain Temper</td>
		<td>Has this posted yet?</th>
		<td>2012/07/07 07:15</th>
	</tr>
	<tr>
		<td>Professor English</td>
		<td>It should be 'Is' not 'Has'.</th>
		<td>2012/07/07 07:17</th>
	</tr>
	<tr>
		<td>Captain Temper</td>
		<td>Has this posted yet?</th>
		<td>2012/07/07 07:18</th>
	</tr>
	<tr>
		<td>Capt. Temper</td>
		<td>Has this posted yet?</th>
		<td>2012/07/07 07:19</th>
	</tr>
</table>

但愿你注意到了最后一行超级英雄名字的不一致性(以及队长一贯的没耐心)

如果我们只看第一列，我们根本不能确定哪一个拼写是正确的——_Captain Temper_还是_Capt. Temper_。这正是我们需要通过标准化消除的冗余数据。

####解决方案细节

在我们介绍完整的标准化解决方案之前，让我们先来简单看一眼Django环境下的数据库层面的标准化。

#####标准化的三步

标准化可以帮助你更高效地存储数据。当你的模型完全地标准化了，他们不应该有任何的冗余数据，每个模型也只会包含与它逻辑相关的数据。

举个简单的例子，如果我们要标准化Post表好让我们可以随意将信息与超级英雄关联，那我们就得把用户信息分离到单独的一个表里。Django默认已经创建了用户表。所以，你只需要引用发布信息的用户的ID就可以了，如下表所示：

<table>
	<tr>
		<th>超级英雄ID</th>
		<th>信息</th>
		<th>发布于</th>
	</tr>
	<tr>
		<td>12</td>
		<td>Has this posted yet?</th>
		<td>2012/07/07 07:15</th>
	</tr>
	<tr>
		<td>8</td>
		<td>It should be 'Is' not 'Has'.</th>
		<td>2012/07/07 07:17</th>
	</tr>
	<tr>
		<td>12</td>
		<td>Has this posted yet?</th>
		<td>2012/07/07 07:18</th>
	</tr>
	<tr>
		<td>12</td>
		<td>Has this posted yet?</th>
		<td>2012/07/07 07:19</th>
	</tr>
</table>

现在不光我们知道有三条数据来自同一个用户(ID是随意给的)，而且我们也能通过查询用户表获取正确的用户名了。

一般来说，你需要先以完全标准化的形式设计你的模型，然后因为性能原因选择性地去标准化一部分。在数据库里，__标准化范式__是一系列可以用来确保你的表是标准化的规则。常用的范式有第一，第二和第三范式，尽管最多可以一直到第五范式。

下一个例子里，我们将会标准化一张表，并创建对应的Django模型。设想有一张名为“_目击_”的表，其中列出了超级英雄第一次被目击使用某种能力或超人类力量。每一条记录储存了他们的出身，超能力，第一次目击的位置，包括经度和纬度。

<table>
	<tr>
		<th>姓名</th>
		<th>出身</th>
		<th>超能力</th>
		<th>第一次目击(经度，纬度，国家，时间)</th>
	</tr>
	<tr>
		<td>Blitz</td>
		<td>外星人</td>
		<td>
			冰冻<br>
			飞行
		</td>
		<td>
			+40.75，-73.99；美国；2014/07/03 23:12<br>
			+34.05，-118.24；美国；2013/03/12 11:30
		</td>
	</tr>
	<tr>
		<td>Hexa</td>
		<td>科学家</td>
		<td>
			念动<br>
			飞行
		</td>
		<td>
			+35.68，+139.73；日本；2010/02/17 20:15<br>
			+31.23，+121.45；中国；2010/02/19 20:30
		</td>
	</tr>
	<tr>
		<td>Traveller</td>
		<td>亿万富翁</td>
		<td>时间旅行</td>
		<td>
			+43.62，+1.45；法国；2010/11/10 08:20
		</td>
	</tr>
</table>

以上位置数据来自[http://www.golombek.com/locations.html](http://www.golombek.com/locations.html)

######第一范式(1NF)

要想满足第一范式，一张表必须：

 - 没有一个属性(格子)包含多个值
 - 主键必须是单独的一列或是多个列的组合(组合键)

让我们尝试把我们的表单转换成一个数据库表。明显的，我们的"_能力_"列不满足第一条规则。

更新过后的表格满足了第一范式的要求。此处主键(标注了<sup>*</sup>)是'_姓名_'和'_能力_'的组合，每一行的主键是独一无二的。

<table>
	<tr>
		<th>姓名<sup>*</sup></th>
		<th>出身</th>
		<th>能力<sup>*</sup></th>
		<th>经度</th>
		<th>纬度</th>
		<th>国家</th>
		<th>时间</th>
	</tr>
	<tr>
		<td>Blitz</td>
		<td>外星人</td>
		<td>冰冻</td>
		<td>+40.75170</td>
		<td>-73.99420</td>
		<td>美国</td>
		<td>2014/07/03 23:12</td>
	</tr>
	<tr>
		<td>Blitz</td>
		<td>外星人</td>
		<td>飞行</td>
		<td>+40.75170</td>
		<td>-73.99420</td>
		<td>美国</td>
		<td>2013/03/12 11:30</td>
	</tr>
	<tr>
		<td>Hexa</td>
		<td>科学家</td>
		<td>念动</td>
		<td>+35.68330</td>
		<td>+139.73330</td>
		<td>日本</td>
		<td>2010/02/17 20:15</td>
	</tr>
	<tr>
		<td>Hexa</td>
		<td>科学家</td>
		<td>飞行</td>
		<td>+35.68330</td>
		<td>+139.73330</td>
		<td>日本</td>
		<td>2010/02/19 20:30</td>
	</tr>
	<tr>
		<td>Traveller</td>
		<td>亿万富翁</td>
		<td>时间旅行</td>
		<td>+43.61670</td>
		<td>+1.45000</td>
		<td>法国</td>
		<td>2010/11/10 08:20</td>
	</tr>
</table>

######第二范式或称2NF

第二范式必须满足第一范式的所有条件。并且，它还必须满足所有的非主键列应该依赖于整个主键。

在上一张表中，注意到'_出身_'只依赖超级英雄，也就是'_姓名_'。至于那一列对应的是哪种_能力_并不重要。因此，_出身_并不依赖于整个组合主键——_姓名_和_能力_。

让我们把出身信息提取到另一张表里，起名为'_出身_'：

<table>
	<tr>
		<th>姓名<sup>*</sup></th>
		<th>出身</th>
	</tr>
	<tr>
		<td>Blitz</td>
		<td>外星人</td>
	</tr>
	<tr>
		<td>Hexa</td>
		<td>科学家</td>
	</tr>
	<tr>
		<td>Traveller</td>
		<td>亿万富翁</td>
	</tr>
</table>

更新以后，我们的_目击_表满足第二范式的要求了：

<table>
	<tr>
		<th>姓名<sup>*</sup></th>
		<th>能力<sup>*</sup></th>
		<th>经度</th>
		<th>纬度</th>
		<th>国家</th>
		<th>时间</th>
	</tr>
	<tr>
		<td>Blitz</td>
		<td>冰冻</td>
		<td>+40.75170</td>
		<td>-73.99420</td>
		<td>美国</td>
		<td>2014/07/03 23:12</td>
	</tr>
	<tr>
		<td>Blitz</td>
		<td>飞行</td>
		<td>+40.75170</td>
		<td>-73.99420</td>
		<td>美国</td>
		<td>2013/03/12 11:30</td>
	</tr>
	<tr>
		<td>Hexa</td>
		<td>念动</td>
		<td>+35.68330</td>
		<td>+139.73330</td>
		<td>日本</td>
		<td>2010/02/17 20:15</td>
	</tr>
	<tr>
		<td>Hexa</td>
		<td>飞行</td>
		<td>+35.68330</td>
		<td>+139.73330</td>
		<td>日本</td>
		<td>2010/02/19 20:30</td>
	</tr>
	<tr>
		<td>Traveller</td>
		<td>时间旅行</td>
		<td>+43.61670</td>
		<td>+1.45000</td>
		<td>法国</td>
		<td>2010/11/10 08:20</td>
	</tr>
</table>

######第三范式或称3NF

满足第三范式的表必须在满足第二范式的基础上，保证所有的非主键列直接依赖于整个主键并且互相之间独立。

让我们看看_国家_列。给定_经度_和_纬度_以后，你可以很容易地推导出_国家_列。尽管超级英雄被目击的国家是依赖于_姓名－能力_的组合主键的，但其实只是间接依赖。

因此，让我们将位置详情分离到_国家_表里：

<table>
	<tr>
		<th>位置ID</th>
		<th>经度<sup>*</sup></th>
		<th>纬度<sup>*</sup></th>
		<th>国家</th>
	</tr>
	<tr>
		<td>1</td>
		<td>+40.775170</td>
		<td>-73.99420</td>
		<td>美国</td>
	</tr>
	<tr>
		<td>2</td>
		<td>+35.68330</td>
		<td>+139.73330</td>
		<td>日本</td>
	</tr>
	<tr>
		<td>3</td>
		<td>+43.61670</td>
		<td>+1.45000</td>
		<td>法国</td>
	</tr>
</table>

现在我们的满足第三范式的_目击_表变成了这个样子：

<table>
	<tr>
		<th>用户ID<sup>*</sup></th>
		<th>能力<sup>*</sup></th>
		<th>位置ID</th>
		<th>时间</th>
	</tr>
	<tr>
		<td>2</td>
		<td>冰冻</td>
		<td>1</td>
		<td>2014/07/03 23:12</td>
	</tr>
	<tr>
		<td>2</td>
		<td>飞行</td>
		<td>1</td>
		<td>2013/03/12 11:30</td>
	</tr>
	<tr>
		<td>4</td>
		<td>念动</td>
		<td>1</td>
		<td>2010/02/17 20:15</td>
	</tr>
	<tr>
		<td>4</td>
		<td>飞行</td>
		<td>2</td>
		<td>2010/02/19 20:30</td>
	</tr>
	<tr>
		<td>7</td>
		<td>时间旅行</td>
		<td>3</td>
		<td>2010/11/10 08:20</td>
	</tr>
</table>

和之前一样，我们将超级英雄的姓名以_用户ID_取代。我们可以通过它来查找用户表。

#####Django模型

接下来我们可以看看应该如何将这些规范化后的表表示成Django模型。Django尚未对组合主键提供直接支持。解决方法是定义一个代理键，然后在`Meta`类里指定`unique_together`属性：

	class Origin(models.Model):
		superhero = models.ForeignKey(settings.AUTH_USER_MODEL)
		origin = models.CharField(max_length=100)


	class Location(models.Model):
		latitude = models.FloatField()
		longitude = models.FloatField()
		country = models.CharField(max_length=100)

		class Meta:
			unique_together = ("latitude", "longitude")


	class Sighting(models.Model):
		superhero = models.ForeignKey(settings.AUTH_USER_MODEL)
		power = models.CharField(max_length=100)
		location = models.ForeignKey(Location)
		sighted_on = models.DateTimeField()

		class Meta:
			unique_together = ("superhero", "power")

####性能和非规范化

规范化可能会对性能造成影响。随着模型数量的增加，在执行查询的时候需要做的联表操作也会增加。举个例子，为了知道在美国会使用冰冻能力的超级英雄的数量，你不得不将上述四张表都联结起来。而在规范化之前，任何信息都可以通过只查询一张表获得。

在设计模型的时候，你应该使你的数据保持规范化。这样有助于维持数据整体性。然而，如果你的网站开始遇到性能瓶颈了，那你也许应该有选择性地从这些模型里选取一些数据来构造一些非规范化的数据。

>最佳实践：
>设计的时候规范化，优化的时候非规范化

举个例子，如果经常需要计算在某个国家的目击总数，那就在`Location`模型里添加一个额外的属性来记录它。然后，不同于缓存值，你可以通过Django(__object-ralational mapping__)__ORM__来对它进行各种各样的查询。

然而，每次你新增或删除一次目击，你都需要更新这个值。你需要将这个过程放到_目击_的`save`方法里，添加一个信号处理，甚至是通过异步任务来更新。

如果你你有另一个复杂的查询需要跨越好几张表，比如计算每个国家的超能力总数，那你又需要创建另一张非规范化表。和之前一样，我们需要在每次更新规范化表的时候同时更新这张非规范化表。

非规范化在大型网站里惊人地常见，因为它通过牺牲空间换取时间。眼下空间非常廉价，而时间则对用户体验有着极大的影响。所以，如果你的请求需要花费很长的时间，请考虑将数据非规范化。

####我们需要一直保持规范化吗？

太多的规范化并不一定是好事。有时候，这会创建一些不必要的，增加查询和更新复杂程度的表。

比如说，你的_User_模型也许有一些储存他们家庭住址的属性。严格地说，你可以把这些属性规范化到_Address_表里。然而，很多情况下，往数据库里引入额外的表都是不必要的。

与其追求最大程度的规范化，不如在重构之前仔细权衡取舍每个可以规范化的部分。

###模式 － model mixins

__问题__： 不同的模型有相同的属性和/或方法，这有违DRY原则。

__解决方案__： 将相同的属性和方法提取出来，构造成一些可重用的mixin。

####问题细节：

在设计模型的时候，你也许会遇到一些不同模型之间共有的通用属性或行为。比如说，一个`Post`和`Comment`模型都需要记录`created`和`modified`的日期。人为地把这些属性复制粘贴到每一个模型并不是一个DRY的做法。

Django的模型都是类，所以面向对象的常用手法，比如组合和继承，都是可行的。然而，组合(用一个属性存储通用类的实例)会使需要访问的属性藏得更深一层。

继承也会变得比较微妙。我们可以为`Post`和`Comments`定义一个基类。然而，在Django里，我们可以使用的继承类型有三种：__实体继承__，__抽象继承__和__代理__。

实体继承是通过定义基类实现的，就和你平时写Python类一样。然而，在Django里，这个基类会被映射到另一张单独的表里。每次你想要访问基类的属性时，都会隐式使用一次联表。最终可能会导致很严重的性能问题。

代理继承只能给父类添加新的方法，无法添加新的属性。所以这并不适用于我们的需求。

所以最后，我们只剩抽象继承可以选择了。

####解决方案细节

